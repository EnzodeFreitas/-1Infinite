<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Sistema Integrado: Mapa + Heatmap + Análise</title>
<style>
  #map { height: 400px; width: 100%; margin-bottom: 20px; }
  svg.calendar { font: 10px sans-serif; }
  rect.day { stroke: #ccc; cursor: pointer; }

  body {
    background: #050f1a;
  }
</style>
<script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>

<h2>Mapa Interativo</h2>
<div id="map"></div>

<h2>Heatmap de Atividade Diária</h2>
<svg class="calendar" width="900" height="130"></svg>

<h2>Gráfico de Rotas por Faixa de Distância</h2>
<canvas id="distanciaChart" width="400" height="200"></canvas>
<br>

<script>

// === VARIÁVEIS GLOBAIS ===
const userActivityByDate = {};
const formatDate = d3.timeFormat("%Y-%m-%d");

const startDate = new Date(new Date().getFullYear(), 0, 1);
const endDate = new Date(new Date().getFullYear() + 1, 0, 1);

window.heatmapData = d3.timeDays(startDate, endDate).map(date => ({ date, value: 0 }));

const color = d3.scaleLinear().domain([0, 5]).range(["#eee", "#d73027"]);

const cellSize = 15;
const svg = d3.select("svg.calendar");

svg.selectAll("rect.day")
  .data(window.heatmapData)
  .join("rect")
  .attr("class", "day")
  .attr("width", cellSize)
  .attr("height", cellSize)
  .attr("x", (d, i) => Math.floor(i / 7) * (cellSize + 2))
  .attr("y", (d, i) => (i % 7) * (cellSize + 2))
  .attr("fill", d => color(d.value))
  .append("title")
  .text(d => formatDate(d.date));

function updateHeatmap() {
  d3.selectAll("rect.day")
    .data(window.heatmapData)
    .transition()
    .duration(300)
    .attr("fill", d => {
      const dateStr = formatDate(d.date);
      const value = userActivityByDate[dateStr] || 0;
      return color(value);
    })
    .select("title")
    .text(d => {
      const dateStr = formatDate(d.date);
      const value = userActivityByDate[dateStr] || 0;
      return `${dateStr}: ${value} atividade(s)`;
    });
}

// === MAPA ===
var map = L.map('map', {
  center: [0, 0],
  zoom: 2,
  minZoom: 2,
  maxZoom: 19,
  maxBounds: [[-90, -180], [90, 180]],
  zoomControl: true
});

L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png').addTo(map);

L.marker([0, 0]).addTo(map).bindPopup('Centro do mapa - Ponto (0, 0)').openPopup();

if (navigator.geolocation) {
  navigator.geolocation.getCurrentPosition(function (position) {
    const lat = position.coords.latitude;
    const lon = position.coords.longitude;
    L.marker([lat, lon]).addTo(map).bindPopup('Você está aqui!').openPopup();
  }, function (error) {
    console.error('Erro ao obter localização:', error);
  });
}

// === DRAW CONTROL ===
var drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

var drawControl = new L.Control.Draw({
  edit: { featureGroup: drawnItems },
  draw: { polygon: true, circle: true, rectangle: true, marker: true, polyline: true }
});
map.addControl(drawControl);

map.on('click', function (e) {
  L.popup()
    .setLatLng(e.latlng)
    .setContent(`Coordenadas:<br>Lat: ${e.latlng.lat.toFixed(5)}<br>Lng: ${e.latlng.lng.toFixed(5)}`)
    .openOn(map);
});

map.on('draw:created', function (event) {
  const layer = event.layer;
  drawnItems.addLayer(layer);

  const today = formatDate(new Date());
  userActivityByDate[today] = (userActivityByDate[today] || 0) + 1;
  updateHeatmap();

  const latlng = layer.getBounds ? layer.getBounds().getCenter() : layer.getLatLng();

  const formHtml = `
    <form id="shapeInfoForm">
      <label for="shapeDescription">Descrição:</label>
      <textarea id="shapeDescription" name="description"></textarea><br><br>
      <label for="shapePhotos">Adicionar foto:</label>
      <input type="file" id="shapePhotos" name="photos" multiple><br><br>
      <button type="submit">Enviar</button>
    </form>
  `;

  const popup = L.popup().setLatLng(latlng).setContent(formHtml).openOn(map);

  document.getElementById("shapeInfoForm").addEventListener("submit", function (e) {
    e.preventDefault();
    const description = document.getElementById("shapeDescription").value;
    const photos = document.getElementById("shapePhotos").files;
    let photoNames = "";
    for (let i = 0; i < photos.length; i++) {
      photoNames += photos[i].name + ", ";
    }
    photoNames = photoNames.slice(0, -2);

    layer.bindPopup("Descrição: " + description + "<br>Fotos: " + (photoNames || "Nenhuma")).openPopup();

    const geojson = layer.toGeoJSON();
    geojson.properties = { descricao: description, tipo: event.layerType, fotos: [] };

    const formData = new FormData();
    formData.append("geojson", JSON.stringify(geojson));
    for (let i = 0; i < photos.length; i++) {
      formData.append("fotos[]", photos[i]);
    }

    fetch("/api/salvar-diario", { method: "POST", body: formData })
      .then(res => res.json())
      .then(data => console.log("Salvo!", data))
      .catch(err => console.error("Erro ao salvar:", err));

    map.closePopup();
  });

  // Atualiza automaticamente o gráfico:
  processarDistanciasEDesenharGrafico();
});

map.on('draw:edited', function (e) {
  e.layers.eachLayer(function (layer) {
    const geojson = layer.toGeoJSON();
    fetch('/api/atualizar-diario', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(geojson)
    })
    .then(res => res.json())
    .then(data => console.log('Atualizado!', data))
    .catch(err => console.error('Erro ao atualizar:', err));
  });

  // Atualiza automaticamente o gráfico:
  processarDistanciasEDesenharGrafico();
});

map.on('draw:deleted', function (e) {
  e.layers.eachLayer(function (layer) {
    const geojson = layer.toGeoJSON();
    fetch('/api/excluir-diario', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(geojson)
    })
    .then(res => res.json())
    .then(data => console.log('Excluído!', data))
    .catch(err => console.error('Erro ao excluir:', err));
  });

  // Atualiza automaticamente o gráfico:
  processarDistanciasEDesenharGrafico();
});

// === GRÁFICO DE DISTÂNCIAS ===
let dadosRotas = [0, 0, 0, 0, 0];

const ctx = document.getElementById('distanciaChart').getContext('2d');
const myChart = new Chart(ctx, {
  type: 'bar',
  data: {
    labels: ['0-1km', '1-2km', '2-3km', '3-4km', '4-5km'],
    datasets: [{
      label: 'Quantidade de Rotas',
      data: dadosRotas,
      backgroundColor: 'rgba(54, 162, 235, 0.6)'
    }]
  },
  options: {
    scales: { y: { beginAtZero: true } }
  }
});

function calcularDistancia(rota) {
  let distancia = 0;
  const pontos = rota.getLatLngs();
  for (let i = 0; i < pontos.length - 1; i++) {
    distancia += pontos[i].distanceTo(pontos[i + 1]) / 1000;
  }
  return distancia;
}

function processarDistanciasEDesenharGrafico() {
  dadosRotas = [0, 0, 0, 0, 0];
  drawnItems.eachLayer(function (layer) {
    if (layer instanceof L.Polyline && !(layer instanceof L.Polygon)) {
      const distancia = calcularDistancia(layer);
      if (distancia <= 1) dadosRotas[0]++;
      else if (distancia <= 2) dadosRotas[1]++;
      else if (distancia <= 3) dadosRotas[2]++;
      else if (distancia <= 4) dadosRotas[3]++;
      else if (distancia <= 5) dadosRotas[4]++;
    }
  });
  myChart.data.datasets[0].data = dadosRotas;
  myChart.update();
  alert("Gráfico de rotas atualizado com sucesso!");
}


</script>
</body>
</html>
