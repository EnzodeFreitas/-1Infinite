<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard | -1Infinite</title>
    <!-- Biblioteca para √≠cone -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/boxicons@latest/css/boxicons.min.css">
    <!-- Bibliteca particle.js -->
    <link rel="stylesheet" href="./css/dash.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Biblioteca D3.js -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
    </style>
</head>

<body class="page-fade-in">
    <!-- SIDE -->
    <div class="side">
        <ul class="social">
            <li class="social-item"><a href="../map.html"><i class="bx bx-arrow-back"></i></a></li>
        </ul>
    </div>
    <h1 class="titulo-principal">An√°lise das Rotas e Ferramentas Utilizadas</h1>
    <div class="separator"></div>
    <div class="graficos">
        <div class="grafico-container">
            <div class="kpi">
                <span>üåç Total de rotas: <strong></strong></span>
            </div>
            <canvas id="myChart"></canvas>
        </div>
        <div class="grafico-container">
            <div class="kpi">
                <span>üìç Ferramenta Mais Usada: <strong></strong></span>
            </div>
            <canvas id="myChart2"></canvas>
        </div>
        <div class="grafico-container">
            <div class="kpi">
                <span>üî• Intensidade de uso por dias <strong></strong></span>
            </div>
            <div id="heatmap"></div>
        </div>
    </div>

    <script>
        // SETUP 
        // LABELS FIXOS PARA CADA HOR√ÅRIO

        // GR√ÅFICO LINHAS - QUANTIDADE DE ROTAS POR FAIXA DE DIST√ÇNCIA
        const labels = ['0‚Äì1 km', '1‚Äì2 km', '2‚Äì3 km', '3‚Äì4 km', '4‚Äì5 km'];

        // GR√ÅFICO BARRAS X FERRAMENTAS
        const labels2 = ['Rota', 'Pol√≠gono criativo', 'Ret√¢ngulo', 'Circunfer√™ncia', 'Marcador', 'Marcador em √Årea'];

        // DADOS FIXOS
        // GR√ÅFICO LINHAS
        const data = {
            labels: labels,
            datasets: [
                {
                    // Dados da quantidade de rotas
                    label: 'Quantidade de Rotas',
                    data: [], // N√∫mero de rotas que ca√≠ram em cada faixa de dist√¢ncia
                    borderColor: 'blue',
                    backgroundColor: 'rgba(0, 0, 255, 0.5)',
                    yAxisID: 'y',
                    tension: 0.3
                }
            ]
        };

        // GR√ÅFICO BARRAS
        const data2 = {
            labels: labels2,
            datasets: [
                {
                    // Dados da quantidade de ferramentas
                    label: 'Quantidade',
                    data: [],
                    borderColor: 'red',
                    borderWidth: 2.5,
                    backgroundColor: 'rgba(255, 0, 0, 0.5)',
                    yAxisID: 'y',
                    tension: 0
                },
            ]
        };

        // CONFIG - GR√ÅFICO LINHAS
        const config = {
            type: 'line', // Tipo de gr√°fico: linha
            data: data, // Dados a serem exibidos
            options: {
                responsive: true, // Faz o gr√°fico se ajustar ao tamanho da tela
                interaction: {
                    mode: 'index', // Intera√ß√£o no gr√°fico em modo √≠ndice
                    intersect: false, // N√£o precisa intersectar as linhas
                },
                stacked: false, // N√£o permitir que as linhas fiquem empilhadas
                plugins: {
                    title: {
                        display: true, // Exibe o t√≠tulo
                        text: 'N√∫mero de Rotas por Faixa de Dist√¢ncia' // Texto do t√≠tulo
                    }
                },
                scales: {
                    // === EIXO X ===
                    x: {
                        title: {
                            display: true, // Exibe o t√≠tulo do eixo X
                            text: 'Faixa de Dist√¢ncia (km)' // Texto do t√≠tulo
                        }
                    },
                    // === EIXO Y ===
                    y: {
                        type: 'linear', // Tipo do eixo Y: linear (num√©rico)
                        display: true, // Exibe o eixo Y
                        position: 'left', // Posi√ß√£o do eixo  
                        min: 0, // Valor m√≠nimo 
                        max: 15, // Valor m√°ximo
                        ticks: {
                            stepSize: 3 // Define o tamanho do incremento (0, 3, 6...)
                        },
                        title: {
                            display: true, // Exibe o t√≠tulo do eixo 
                            text: 'Quantidade de rotas'
                        }
                    },
                }
            },
        };

        // CONFIG - GR√ÅFICO DE BARRAS
        const config2 = {
            type: 'bar', // Gr√°fico de barras
            data: data2,
            options: {
                responsive: true,
                interaction: {
                    mode: 'index',
                    intersect: false,
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'Ferramentas utilizadas'
                    }
                },
                scales: {
                    x: {
                        title: {
                            display: true,
                            text: 'Formas'
                        }
                    },
                    y: { // ===== Y FERRAMENTAS =====//
                        type: 'linear',
                        display: true,
                        position: 'left',
                        min: 0,
                        max: 40,
                        ticks: {
                            stepSize: 5
                        },
                        title: {
                            display: true,
                            text: 'Quantidade'
                        }
                    },
                }
            }
        };

        // CRIANDO O GR√ÅFICO DE LINHAS
        const myChart = new Chart(
            document.getElementById('myChart'), // O canvas onde o gr√°fico ser√° desenhado
            config // A configura√ß√£o do gr√°fico de linha

        );

        // CRIANDO O GR√ÅFICO DE BARRAS
        const myChart2 = new Chart(
            document.getElementById('myChart2'),
            config2
        );

        // ===== CALENDAR HEATMAP =====
        const year = new Date().getFullYear();
        const width = 1000, height = 150, cellSize = 17;
        const svg = d3.select("#heatmap").append("svg")
            .attr("width", width)
            .attr("height", height);
        const g = svg.append("g").attr("transform", "translate(40,20)");
        const color = d3.scaleQuantize()
            .domain([0, 10])
            .range(["#050f1a", "#c6e48b", "#7bc96f", "#239a3b", "#196127"]);
        const dayLabels = ["D", "S", "T", "Q", "Q", "S", "S"];
        const tooltip = d3.select("body").append("div")
            .attr("class", "tooltip").style("opacity", 0);

        g.selectAll(".day-label")
            .data(dayLabels)
            .join("text")
            .attr("class", "day-label")
            .attr("x", -5)
            .attr("y", (d, i) => i * cellSize + 12)
            .attr("text-anchor", "end")
            .text(d => d);

        g.selectAll(".month")
            .data(d3.timeMonths(new Date(year, 0, 1), new Date(year + 1, 0, 1)))
            .join("text")
            .attr("class", "month-label") // Classe para estilizar
            .attr("x", d => d3.timeWeek.count(d3.timeYear(d), d) * cellSize)
            .attr("y", -5)
            .text(d3.timeFormat("%b"));

        const allDates = d3.timeDays(new Date(year, 0, 1), new Date(year + 1, 0, 1));
        let heatmapData = allDates.map(d => ({ date: d, value: 0 }));

        function formatDate(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        function updateHeatmap() {

            g.selectAll("rect.day")
                .data(heatmapData, d => formatDate(d.date))
                .join(
                    enter => enter.append("rect")
                        .attr("class", "day")
                        .attr("width", cellSize)
                        .attr("height", cellSize)
                        .attr("x", d => d3.timeWeek.count(d3.timeYear(d.date), d.date) * cellSize)
                        .attr("y", d => d.date.getDay() * cellSize)
                        .attr("fill", d => color(d.value))
                        .on("mouseover", (event, d) => {
                            tooltip.transition().duration(200).style("opacity", 0.9);
                            tooltip.html(`${formatDate(d.date)}<br/>${d.value} atividades`)
                                .style("left", (event.pageX + 10) + "px")
                                .style("top", (event.pageY - 20) + "px");
                        })
                        .on("mouseout", () => {
                            tooltip.transition().duration(500).style("opacity", 0);
                        }),
                    update => update.transition().duration(300).attr("fill", d => color(d.value))
                );
        }

        // Atualiza sempre que o localStorage mudar (inclusive entre abas)
        window.addEventListener("storage", () => updateHeatmap());

        updateHeatmap();
    </script>

</body>

</html>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        document.body.classList.add('loaded');
    });

    

    let proximaAtualizacao;

    // indow.onload = exibirAquariosDoUsuario();

    // O gr√°fico √© constru√≠do com tr√™s fun√ß√µes:
    // 1. obterDadosGrafico -> Traz dados do Banco de Dados para montar o gr√°fico da primeira vez
    // 2. plotarGrafico -> Monta o gr√°fico com os dados trazidos e exibe em tela
    // 3. atualizarGrafico -> Atualiza o gr√°fico, trazendo novamente dados do Banco

    // Esta fun√ß√£o *obterDadosGrafico* busca os √∫ltimos dados inseridos em tabela de medidas.
    // para, quando carregar o gr√°fico da primeira vez, j√° trazer com v√°rios dados.
    // A fun√ß√£o *obterDadosGrafico* tamb√©m invoca a fun√ß√£o *plotarGrafico*

    //     Se quiser alterar a busca, ajuste as regras de neg√≥cio em src/controllers
    //     Para ajustar o "select", ajuste o comando sql em src/models
    function obterDadosGrafico(id) {

        alterarTitulo(id)

        if (proximaAtualizacao != undefined) {
            clearTimeout(proximaAtualizacao);
        }

        fetch(`/medidas/ultimas/${id}`, { cache: 'no-store' }).then(function (response) {
            if (response.ok) {
                response.json().then(function (resposta) {
                    console.log(`Dados recebidos: ${JSON.stringify(resposta)}`);
                    resposta.reverse();

                    plotarGrafico(resposta, id);

                });
            } else {
                console.error('Nenhum dado encontrado ou erro na API');
            }
        })
            .catch(function (error) {
                console.error(`Erro na obten√ß√£o dos dados p/ gr√°fico: ${error.message}`);
            });
    }

    // Esta fun√ß√£o *plotarGrafico* usa os dados capturados na fun√ß√£o anterior para criar o gr√°fico
    // Configura o gr√°fico (cores, tipo, etc), materializa-o na p√°gina e, 
    // A fun√ß√£o *plotarGrafico* tamb√©m invoca a fun√ß√£o *atualizarGrafico*
    function plotarGrafico(resposta, id) {

        console.log('iniciando plotagem do gr√°fico...');

        // Criando estrutura para plotar gr√°fico - labels
        let labels = [];

        // Criando estrutura para plotar gr√°fico - dados
        let dados = {
            labels: labels,
            datasets: [{
                label: 'Umidade',
                data: [],
                fill: false,
                borderColor: 'rgb(75, 192, 192)',
                tension: 0.1
            },
            {
                label: 'Temperatura',
                data: [],
                fill: false,
                borderColor: 'rgb(199, 52, 52)',
                tension: 0.1
            }]
        };

        console.log('----------------------------------------------')
        console.log('Estes dados foram recebidos pela funcao "obterDadosGrafico" e passados para "plotarGrafico":')
        console.log(resposta)

        // Inserindo valores recebidos em estrutura para plotar o gr√°fico
        for (i = 0; i < resposta.length; i++) {
            var registro = resposta[i];
            labels.push(registro.momento_grafico);
            dados.datasets[0].data.push(registro.umidade);
            dados.datasets[1].data.push(registro.temperatura);
        }

        console.log('----------------------------------------------')
        console.log('O gr√°fico ser√° plotado com os respectivos valores:')
        console.log('Labels:')
        console.log(labels)
        console.log('Dados:')
        console.log(dados.datasets)
        console.log('----------------------------------------------')

        // Criando estrutura para plotar gr√°fico - config
        const config = {
            type: 'line',
            data: dados,
        };

        // Adicionando gr√°fico criado em div na tela
        let myChart = new Chart(
            document.getElementById(`myChartCanvas${id}`),
            config
        );

        setTimeout(() => atualizarGrafico(id, dados, myChart), 2000);
    }


    // Esta fun√ß√£o *atualizarGrafico* atualiza o gr√°fico que foi renderizado na p√°gina,
    // buscando a √∫ltima medida inserida em tabela contendo as capturas, 

    //     Se quiser alterar a busca, ajuste as regras de neg√≥cio em src/controllers
    //     Para ajustar o "select", ajuste o comando sql em src/models
    function atualizarGrafico(id, dados, myChart) {



        fetch(`/medidas/tempo-real/${id}`, { cache: 'no-store' }).then(function (response) {
            if (response.ok) {
                response.json().then(function (novoRegistro) {

                    obterdados(id);
                    // alertar(novoRegistro, id);
                    console.log(`Dados recebidos: ${JSON.stringify(novoRegistro)}`);
                    console.log(`Dados atuais do gr√°fico:`);
                    console.log(dados);

                    let avisoCaptura = document.getElementById(`avisoCaptura${id}`)
                    avisoCaptura.innerHTML = ""


                    if (novoRegistro[0].momento_grafico == dados.labels[dados.labels.length - 1]) {
                        console.log("---------------------------------------------------------------")
                        console.log("Como n√£o h√° dados novos para captura, o gr√°fico n√£o atualizar√°.")
                        avisoCaptura.innerHTML = "<i class='fa-solid fa-triangle-exclamation'></i> Foi trazido o dado mais atual capturado pelo sensor. <br> Como n√£o h√° dados novos a exibir, o gr√°fico n√£o atualizar√°."
                        console.log("Hor√°rio do novo dado capturado:")
                        console.log(novoRegistro[0].momento_grafico)
                        console.log("Hor√°rio do √∫ltimo dado capturado:")
                        console.log(dados.labels[dados.labels.length - 1])
                        console.log("---------------------------------------------------------------")
                    } else {
                        // tirando e colocando valores no gr√°fico
                        dados.labels.shift(); // apagar o primeiro
                        dados.labels.push(novoRegistro[0].momento_grafico); // incluir um novo momento

                        dados.datasets[0].data.shift();  // apagar o primeiro de umidade
                        dados.datasets[0].data.push(novoRegistro[0].umidade); // incluir uma nova medida de umidade

                        dados.datasets[1].data.shift();  // apagar o primeiro de temperatura
                        dados.datasets[1].data.push(novoRegistro[0].temperatura); // incluir uma nova medida de temperatura

                        myChart.update();
                    }

                    // Altere aqui o valor em ms se quiser que o gr√°fico atualize mais r√°pido ou mais devagar
                    proximaAtualizacao = setTimeout(() => atualizarGrafico(id, dados, myChart), 2000);
                });
            } else {
                console.error('Nenhum dado encontrado ou erro na API');
                // Altere aqui o valor em ms se quiser que o gr√°fico atualize mais r√°pido ou mais devagar
                proximaAtualizacao = setTimeout(() => atualizarGrafico(id, dados, myChart), 2000);
            }
        })
            .catch(function (error) {
                console.error(`Erro na obten√ß√£o dos dados p/ gr√°fico: ${error.message}`);
            });
    }
</script>